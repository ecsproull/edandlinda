//go:build ignore
// +build ignore

package main

import (
	"database/sql"
	"fmt"
	"goserver/internal/database"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

type Column struct {
	Name       string
	GoType     string
	JSONTag    string
	DBTag      string
	SQLType    string
	IsNullable bool
}

type Table struct {
	Name    string
	Columns []Column
}

// getTableSchemas connects to your database and reads the schema
func getTableSchemas() ([]Table, error) {
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found or error loading .env file")
	}

	// Connect to PostgreSQL database
	if err := database.ConnectDatabase(); err != nil {
		log.Fatal("Failed to connect to database:", err)
	} else {
		log.Println("Database connection established")
	}
	defer database.CloseDatabase()

	// Get all tables
	tables := []string{"users", "blogs", "places", "comments"} // Your table names
	var result []Table

	for _, tableName := range tables {
		table, err := getTableSchema(database.DB.DB, tableName)
		if err != nil {
			log.Printf("Error getting schema for table %s: %v", tableName, err)
			continue
		}
		result = append(result, table)
	}

	return result, nil
}

// getTableSchema gets the schema for a specific table
func getTableSchema(db *sql.DB, tableName string) (Table, error) {
	query := `
        SELECT column_name, data_type, is_nullable, column_default
        FROM information_schema.columns 
        WHERE table_name = $1 AND table_schema = 'public'
        ORDER BY ordinal_position
    `

	rows, err := db.Query(query, tableName)
	if err != nil {
		return Table{}, err
	}
	defer rows.Close()

	var columns []Column
	for rows.Next() {
		var colName, dataType, nullable string
		var defaultVal sql.NullString

		err := rows.Scan(&colName, &dataType, &nullable, &defaultVal)
		if err != nil {
			continue
		}

		column := Column{
			Name:       toCamelCase(colName),
			GoType:     mapSQLTypeToGoType(dataType, nullable == "YES"),
			JSONTag:    colName,
			DBTag:      colName,
			SQLType:    dataType,
			IsNullable: nullable == "YES",
		}
		columns = append(columns, column)
	}

	return Table{
		Name:    toCamelCase(tableName),
		Columns: columns,
	}, nil
}

// mapSQLTypeToGoType converts PostgreSQL types to Go types
func mapSQLTypeToGoType(sqlType string, isNullable bool) string {
	var baseType string

	switch strings.ToLower(sqlType) {
	case "integer", "serial", "bigint", "bigserial":
		baseType = "int"
	case "smallint", "smallserial":
		baseType = "int16"
	case "text", "varchar", "character varying", "char", "character":
		baseType = "string"
	case "boolean":
		baseType = "bool"
	case "timestamp", "timestamp with time zone", "timestamp without time zone":
		baseType = "time.Time"
	case "date":
		baseType = "time.Time"
	case "numeric", "decimal", "real", "double precision":
		baseType = "float64"
	case "json", "jsonb":
		baseType = "interface{}"
	default:
		baseType = "interface{}"
	}

	if isNullable && baseType != "interface{}" {
		return "*" + baseType
	}
	return baseType
}

// toCamelCase converts snake_case to CamelCase
func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + strings.ToLower(part[1:])
		}
	}
	return strings.Join(parts, "")
}

// generateModel creates a Go file with the struct definition
func generateModel(table Table) error {
	tmpl := `// Code generated by generate_models.go. DO NOT EDIT.

package models

import (
    "time"
)

type {{.Name}} struct {
{{- range .Columns}}
    {{.Name}} {{.GoType}} ` + "`json:\"{{.JSONTag}}\" db:\"{{.DBTag}}\"`" + `
{{- end}}
}
`

	t, err := template.New("model").Parse(tmpl)
	if err != nil {
		return err
	}

	filename := fmt.Sprintf("internal/models/generated_%s.go", strings.ToLower(table.Name))
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	return t.Execute(file, table)
}

func main() {
	log.Println("Generating models from database schema...")

	tables, err := getTableSchemas()
	if err != nil {
		log.Fatal("Failed to get table schemas:", err)
	}

	for _, table := range tables {
		log.Printf("Generating model for table: %s", table.Name)
		if err := generateModel(table); err != nil {
			log.Printf("Failed to generate model for %s: %v", table.Name, err)
		}
	}

	log.Println("Model generation complete!")
}
